{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import abc\n",
    "\n",
    "%matplotlib inline"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "class AbstractUDMIS(abc.ABC):\n",
    "    @abc.abstractmethod\n",
    "    def energy(self):\n",
    "        \"\"\"Returns the energy of the current Rydberg occupation configuration\"\"\"\n",
    "\n",
    "    @abc.abstractmethod\n",
    "    def energy_diff(self, *coords):\n",
    "        \"\"\"Returns the energy difference resulting from flipping the occupation at the given coordinates\"\"\"\n",
    "        \n",
    "    @abc.abstractmethod\n",
    "    def rand_vertex(self):\n",
    "        \"\"\"Selects a site in the graph at random\"\"\"\n",
    "    \n",
    "    def mc_step(self, T):\n",
    "        \"\"\"Performs a full update of the Rydberg model using the Metropolis-Hastings algorithm\"\"\"\n",
    "        current_energy = self.energy()\n",
    "        for _ in range(self.num_vertices):\n",
    "            vertex = self.rand_vertex()\n",
    "            dE = self.energy_diff(vertex)\n",
    "            \n",
    "            if (dE < 0) or (np.random.rand() < np.exp(-dE / T)):\n",
    "                current_energy += dE\n",
    "                self.occupations[vertex] ^= 1 \n",
    "                # flips occupation 0 --> 1 OR 1 --> 0\n",
    "\n",
    "        return current_energy"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "class UDMIS(AbstractUDMIS):\n",
    "    def __init__(self, u, graph):\n",
    "        super().__init__()\n",
    "        self.u, self.graph = u, graph\n",
    "        self.num_vertices = len(self.graph)\n",
    "        print(self.num_vertices)\n",
    "        # initialize system at infinite temperature\n",
    "        # i.e. vertices are completely random and uncorrelated\n",
    "        self.occupations = np.random.rand(self.num_vertices) < 0.5\n",
    "        self.edges = self.find_edges()\n",
    "    \n",
    "    def find_edges(self):\n",
    "        #num_pairs = int(self.num_vertices*(self.num_vertices)*0.5)\n",
    "        edges = np.zeros((self.num_vertices, self.num_vertices), dtype=bool)\n",
    "        \n",
    "        for i in range(self.num_vertices-1):\n",
    "            x_i, y_i = graph[i] # these are the x, y coordinates of the i'th vertex in the graph\n",
    "            for j in range(i+1, self.num_vertices):\n",
    "                x_j, y_j = graph[j] # these are the x, y coordinates of the j'th vertex in the graph\n",
    "                \n",
    "                # calculate the distance between vertices\n",
    "                dij = np.sqrt((x_i - x_j)**2. + (y_i - y_j)**2.)\n",
    "                if dij <= 1.0:\n",
    "                    edges[i,j] = True\n",
    "                    edges[j,i] = True\n",
    "                    \n",
    "        return edges\n",
    "        \n",
    "    def energy(self):\n",
    "        \"\"\"Returns the energy of the current spin configuration\"\"\"\n",
    "        # interaction term\n",
    "        interaction_term = 0\n",
    "        vertex_term = 0\n",
    "        for i in range(self.num_vertices-1):\n",
    "            for j in range(i+1, self.num_vertices):\n",
    "                \n",
    "                # check if there is an edge\n",
    "                if self.edges[i,j]:\n",
    "                    interaction_term += self.occupations[i]*self.occupations[j]\n",
    "                \n",
    "            vertex_term += self.occupations[i]\n",
    "        \n",
    "        # missed the last vertex\n",
    "        vertex_term += self.occupations[self.num_vertices-1]\n",
    "    \n",
    "        return u*interaction_term - vertex_term\n",
    "\n",
    "    def energy_diff(self, i):\n",
    "        connections = np.where(self.edges[i,:])[0]\n",
    "        num_adjacent_occupied = sum(self.occupations[connections])\n",
    "        \n",
    "        if self.occupations[i] == 1:\n",
    "            # flipping an occupied vertex increases the vertex term, decreases the interaction term\n",
    "            vertex_term_change = 1.\n",
    "            interaction_term_change = -u*num_adjacent_occupied\n",
    "        \n",
    "        elif self.occupations[i] == 0:\n",
    "            # flipping an unoccupied vertex decreases the vertex term, increases the interaction term\n",
    "            vertex_term_change = -1.\n",
    "            interaction_term_change = u*num_adjacent_occupied \n",
    "\n",
    "        return interaction_term_change + vertex_term_change\n",
    "    \n",
    "    def rand_vertex(self):\n",
    "        \"\"\"Selects a site in the graph at random\"\"\"\n",
    "        return np.random.randint(self.num_vertices)  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "6\n"
     ]
    }
   ],
   "source": [
    "u = 1.35\n",
    "\n",
    "graph = [(0.3461717838632017, 1.4984640297338632), \n",
    "         (0.6316400411846113, 2.5754677320579895), \n",
    "         (1.3906262250927481, 2.164978861396621), \n",
    "         (0.66436005100802, 0.6717919819739032), \n",
    "         (0.8663329771713457, 3.3876341010035995), \n",
    "         (1.1643107343501296, 1.0823066243402013)\n",
    "        ]\n",
    "\n",
    "udmis = UDMIS(u, graph)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\nDHRJaoSBLkmNMNAlqREGuiQ1wkCXpEYY6JLUCANdkhpx0aALkNS+w0cWmJmd5/jiErtHR5iemmD/\nvvFBl9UcA13Sljp8ZIGDh46ydPI0AAuLSxw8dBTAUO8xp1wkbamZ2flHw/yMpZOnmZmdH1BF7TLQ\nJW2p44tLG2rX5hnokrbU7tGRDbVr89YN9CQfTPJgkq+tcT5J3pvkWJK7kjy/92VK2q6mpyYYGR46\np21keIjpqYkBVdSubp7QPwRcdZ7zLwYu67wOAO+/8LIktWL/vnH+6mXPZnx0hADjoyP81cue7YLo\nFlh3l0tV3Zxk73m6XAN8pKoKuCXJaJKLq+qBXhUpaXvbv2/cAO+DXsyhjwP3nfX+/k6bJKmP+roo\nmuRAkrkkcydOnOjnrSWpeb0I9AXg0rPeX9Jp+wlVdX1VTVbV5NjYWA9uLUk6oxeBfgPw6s5ulyuA\nh50/l6T+W3dRNMnHgSuBXUnuB94JDANU1XXAjcDVwDHgB8Brt6pYSdLautnl8sp1zhfwhp5VJEna\nFD8pKkmNMNAlqREGuiQ1wkCXpEYY6JLUCANdkhphoEtSIwx0SWqEgS5JjTDQJakRBrokNcJAl6RG\nGOiS1AgDXZIaYaBLUiMMdElqxLp/wYV2tsNHFpiZnef44hK7R0eYnppg/77xQZclaRUGutZ0+MgC\nBw8dZenkaQAWFpc4eOgogKEuPQY55aI1zczOPxrmZyydPM3M7PyAKpJ0Pga61nR8cWlD7ZIGy0DX\nmnaPjmyoXdJgGeha0/TUBCPDQ+e0jQwPMT01MaCKJJ2Pi6Ja05mFT3e5SNuDga7z2r9v3ACXtgmn\nXCSpEQa6JDXCQJekRhjoktQIA12SGpGqGsyNkxPAtwZyc9gFfHtA9+6nnTJO2DljdZzt2ehYn1pV\nY6udGFigD1KSuaqaHHQdW22njBN2zlgdZ3t6OVanXCSpEQa6JDVipwb69YMuoE92yjhh54zVcban\nZ2PdkXPoktSinfqELknNaTrQk1yVZD7JsSR/fp5+L09SSbblqno340zye0nuSXJ3kn/ud429sN44\nk+xJclOSI0nuSnL1IOq8UEk+mOTBJF9b43ySvLfzdbgryfP7XWMvdDHO3++M72iSLyd5br9r7JX1\nxnpWv19OcirJtZu6UVU1+QKGgP8EfgF4PHAn8IxV+j0JuBm4BZgcdN1bMU7gMuAI8LOd9z836Lq3\naJzXA6/vHD8D+O9B173Jsf468Hzga2ucvxr4HBDgCuDWQde8ReP81bO+Z1+8XcfZzVg7fYaALwA3\nAtdu5j4tP6FfDhyrqm9W1f8CnwCuWaXfXwJ/Dfywn8X1UDfj/GPg76vquwBV9WCfa+yFbsZZwE93\njn8GON7H+nqmqm4GvnOeLtcAH6lltwCjSS7uT3W9s944q+rLZ75nWX7guqQvhW2BLv6bArwJ+Ayw\n6f8/Ww70ceC+s97f32l7VOdH1Uur6l/7WViPrTtO4OnA05P8e5JbklzVt+p6p5tx/gXwB0nuZ/kp\n5039Ka3vuvlatOZ1LP9U0qQk48DvAO+/kOvs2L/gIsnjgPcArxlwKf1wEcvTLley/JRzc5JnV9Xi\nIIvaAq8EPlRVf5PkBcBHkzyrqn486MK0eUl+g+VA/7VB17KF/g74s6r6cZJNX6TlQF8ALj3r/SWd\ntjOeBDwL+LfOF/ApwA1JXlpVc32r8sKtN05YfoK7tapOAv+V5BssB/xX+1NiT3QzztcBVwFU1X8k\neQLLvydjO04xnU83X4smJHkO8E/Ai6vqoUHXs4UmgU90smgXcHWSU1V1eCMXaXnK5avAZUl+Psnj\ngVcAN5w5WVUPV9WuqtpbVXtZnqPbbmEO64yz4zDLT+ck2cXyFMw3+1hjL3Qzzv8BfgsgyS8CTwBO\n9LXK/rgBeHVnt8sVwMNV9cCgi+q1JHuAQ8Crquobg65nK1XVz5+VRZ8G/mSjYQ4NP6FX1akkbwRm\nWV49/mBV3Z3k3cBcVa0Mg22py3HOAr+d5B7gNDC93Z52uhzn24B/TPJWlhdIX1Od7QPbSZKPs/wH\n8K7OesA7gWGAqrqO5fWBq4FjwA+A1w6m0gvTxTjfATwZ+IfOk+up2qa/sKuLsfbmPtvw+12StIqW\np1wkaUcx0CWpEQa6JDXCQJekRhjoktQIA12SGmGgS1IjDHRJasT/AemTkaECgIdPAAAAAElFTkSu\nQmCC\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.scatter([item[0] for item in graph], [item[1] for item in graph]);"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "200 -1.2999999999999998 [False  True False  True  True  True]\n",
      "300 -2.0 [ True False  True False False False]\n",
      "400 -0.6499999999999999 [False False False  True False  True]\n",
      "500 -1.65 [False  True False  True False  True]\n",
      "600 -2.65 [False False  True  True  True  True]\n",
      "700 -3.0 [False False  True False  True  True]\n"
     ]
    }
   ],
   "source": [
    "N = 1000\n",
    "t = np.arange(N+1)\n",
    "T_i = 1000\n",
    "T_f = 0.001\n",
    "\n",
    "T = T_i * ((T_f/T_i) ** (t/N))\n",
    "\n",
    "E_list = []\n",
    "\n",
    "for t in range(N):\n",
    "    # take a look at the abstract_udmis.py file to see how mc_step works\n",
    "    temp = T[t]\n",
    "    \n",
    "    E_list.append(udmis.mc_step(T=temp))\n",
    "    \n",
    "    if t > N*0.1:\n",
    "        \n",
    "        if t % 100 == 0:\n",
    "            print(t, E_list[t], udmis.occupations)\n",
    "    \n",
    "            if (E_list[t] == E_list[t-1])&(E_list[t-1] == E_list[t-2])&(E_list[t] <= min(E_list)):\n",
    "                #print(E_list)\n",
    "                break"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
